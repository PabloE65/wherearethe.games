<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N6YY39T8TQ"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-N6YY39T8TQ');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Where are the games?</title>

    <link href="assets/favicon.png" rel="icon">
    <link href="assets/favicon.png" rel="apple-touch-icon">

    <!-- Meta Description (Crucial for Search Engine Results) -->
    <meta name="description"
        content="Find video games tailored to your preferences by filtering through country, culture, and more. Discover games you'll love on Where Are The Games.">

    <!-- Meta Keywords (Less relevant but can still help) -->
    <meta name="keywords"
        content="video games, game discovery, cultural games, games by country, find games, personalized game recommendations">

    <!-- Author -->
    <meta name="author" content="Where Are The Games">
    <meta property="og:title" content="Discover Video Games by Country and Culture - Where Are The Games">
    <meta property="og:description"
        content="Explore and find video games that match your culture and country preferences.">
    <meta property="og:url" content="https://wherearethe.games">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    <link rel="canonical" href="https://wherearethe.games">
    <link href="main.css" rel="stylesheet">
</head>

<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="https://wherearethe.games">Where are the games?
                    <img src="assets/logo.png" alt="logo" style="width: 50px; height: 50px; position: absolute; top: -15px; margin-left: 10px; margin-top: 5px">
                </a>
            </div>
            <button class="nav-toggle" aria-label="toggle navigation">
                ☰
            </button>
            <div class="nav-links">
                <a href="/contribute">Add data</a>
                <a href="/contact">Contact</a>
            </div>
        </div>
    </nav>
    <div class="center-container">
        <div class="filter-row">
            <div id="filterButtons-country"></div>
            <div id="filterButtons-year"></div>
            <div id="filterButtons-genre"></div>
            <div id="filterButtons-platforms"></div>

            <!-- Order By Section -->
            <div id="filterButtons-orderby" class="order-section">
                <label for="order-by">Order by: </label>
                <select id="order-by">
                    <option value="alphabetical">Alphabetical</option>
                    <!-- <option value="date">Date</option> -->
                </select>
                <button id="sort-toggle" class="sort-button" data-order="ascending">
                    <span id="sort-text">Ascending</span>
                    <span id="arrow">↑</span>
                </button>
            </div>


        </div>


        <div id="gameCountDisplay"></div>
    </div>
    <div class="container" id="gameContainer"></div>

    <script>
        let allGames = [];  // Global variable to store all games
        // Global variables to store filters
        let bitVector_countries = [];
        let bitVector_years = [];
        let bitVector_genres = []
        let bitVector_platforms = []

        let uniqueCountries = new Set(["Chile", "Denmark", "Sweden", "Finland", "Estonia", "Austria", "Hungary", "Poland", "Switzerland"]);

        const navToggle = document.querySelector('.nav-toggle');
        const navLinks = document.querySelector('.nav-links');

        // ascending and descending
        document.getElementById('sort-toggle').addEventListener('click', function () {
            const sortButton = document.getElementById('sort-toggle');
            const currentOrder = sortButton.getAttribute('data-order');
            const newOrder = currentOrder === 'ascending' ? 'descending' : 'ascending';
            sortButton.setAttribute('data-order', newOrder);
            document.getElementById('sort-text').innerText = newOrder.charAt(0).toUpperCase() + newOrder.slice(1);
        });


        navToggle.addEventListener('click', () => {
            navLinks.classList.toggle('active');
        });

        function updateGameCountDisplay(bitVector_games) {
            const sum = bitVector_games.reduce((acc, val) => acc + val, 0);
            const total = bitVector_games.length;
            document.getElementById('gameCountDisplay').textContent =
                `Showing ${sum} out of ${total} games`;
        }

        // Function to parse CSV text into an array of objects
        function parseCSV(csvText) {
            const rows = csvText.split('\n');
            const headers = rows[0].split(';;');

            return rows.slice(1, -1).map(row => {
                const values = row.split(';;');

                return headers.reduce((obj, header, index) => {
                    let value = values[index]?.trim() || '';

                    // Check if the header is 'Release_Date' and try to convert it into a Date object
                    if (header.trim() === 'Release_Date') {
                        value = new Date(value);
                    }

                    obj[header.trim()] = value;
                    return obj;
                }, {});
            });
        }

        async function fetchCSVData(url) {
            try {
                const response = await fetch(url);
                const csvText = await response.text();
                return parseCSV(csvText);
            } catch (error) {
                console.error('Error fetching CSV:', error);
                return [];
            }
        }


        async function fetchMultipleCSVData(urls) {
            const fetchPromises = urls.map(url => fetchCSVData(url));
            const results = await Promise.all(fetchPromises);
            return results.flat();
        }

        async function fetchCSVData(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
                }
                const csvText = await response.text();
                return parseCSV(csvText); // Process CSV into usable data
            } catch (error) {
                console.error(`Error fetching or processing ${url}:`, error);
                return []; // Return an empty array if there's an error
            }
        }

        function createCountryFilterButtons() {
            const filterContainer = document.getElementById('filterButtons-country');
            filterContainer.innerHTML = '<select id="countryFilter" onchange="filter_by_country(this.value)">' +
                '<option value="all">All Countries</option>';

            // Assuming uniqueCountries (global variable) is already defined and populated
            uniqueCountries.forEach(country => {
                filterContainer.querySelector('select').innerHTML += `<option value="${country}">${country}</option>`;
            });

            // Add change event listener to highlight the selected option
            filterContainer.querySelector('select').addEventListener('change', function (e) {
                this.classList.add('active');
            });
        }

        function createGenreFilterButtons() {
            const filterContainer = document.getElementById('filterButtons-genre');

            // Genre filter
            filterContainer.innerHTML += '<select id="genreFilter" onchange="filter_by_genre(this.value)">' +
                '<option value="all">All Genres</option>';

            // Extract all unique genres
            const uniqueGenres = [...new Set(allGames.flatMap(game =>
                game.Genre.split(',').map(genre => genre.trim())
            ))];
            uniqueGenres.sort();

            uniqueGenres.forEach(genre => {
                const displayGenre = genre || "Unspecified";
                filterContainer.querySelector('#genreFilter').innerHTML += `<option value="${genre}">${displayGenre}</option>`;
            });

            // Add change event listeners to highlight the selected options
            filterContainer.querySelectorAll('select').forEach(select => {
                select.addEventListener('change', function (e) {
                    this.classList.add('active');
                });
            });
        }

        function filter_by_genre(genre) {
            if (genre === 'all') {
                bitVector_genres.fill(1);
            } else {
                bitVector_genres = allGames.map(game =>
                    game.Genre.split(',').map(g => g.trim()).includes(genre) ? 1 : 0
                );
            }
            refresh();
            // Highlight the appropriate option
            const genreFilter = document.getElementById('genreFilter');
            genreFilter.value = genre;
            genreFilter.classList.add('active');
        }

        // Function to create filter buttons for years
        function createYearFilterButtons() {
            const filterContainer = document.getElementById('filterButtons-year');
            filterContainer.innerHTML = '<select id="yearFilter" onchange="filter_by_year(this.value)">' +
                '<option value="all">All Years</option>';

            const uniqueYears = [...new Set(allGames.map(game => game.Release_Date.getFullYear()))];
            uniqueYears.sort((a, b) => b - a);

            // Create an option for each unique year
            uniqueYears.forEach(year => {
                const displayYear = isNaN(year) ? "To be announced" : year;
                filterContainer.querySelector('select').innerHTML += `<option value="${displayYear}">${displayYear}</option>`;
            });

            // Add change event listener to highlight the selected option
            filterContainer.querySelector('select').addEventListener('change', function (e) {
                this.classList.add('active');
            });
        }

        function createPlatformFilterButtons() {
            const filterContainer = document.getElementById('filterButtons-platforms');

            // Platform filter
            filterContainer.innerHTML += '<select id="platformFilter" onchange="filter_by_platform(this.value)">' +
                '<option value="all">All Platforms</option>';

            // Extract all unique platforms
            const uniquePlatforms = [...new Set(allGames.flatMap(game =>
                game.Platform.split(',').map(platform => platform.trim())
            ))];
            uniquePlatforms.sort();

            uniquePlatforms.forEach(platform => {
                const displayPlatform = platform || "Unspecified";
                filterContainer.querySelector('#platformFilter').innerHTML += `<option value="${platform}">${displayPlatform}</option>`;
            });

            // Add change event listeners to highlight the selected options
            filterContainer.querySelectorAll('select').forEach(select => {
                select.addEventListener('change', function (e) {
                    this.classList.add('active');
                });
            });
        }

        function filter_by_platform(platform) {
            if (platform === 'all') {
                bitVector_platforms.fill(1);
            } else {
                bitVector_platforms = allGames.map(game =>
                    game.Platform.split(',').map(p => p.trim()).includes(platform) ? 1 : 0
                );
            }
            refresh();
            // Highlight the appropriate option
            const platformFilter = document.getElementById('platformFilter');
            platformFilter.value = platform;
            platformFilter.classList.add('active');
        }


        // Function to create a game card HTML
        function createGameCard(game) {
            return `<div class="game-card">
    <div class="game-header">${game.Name}</div><img src="${game.Thumbnail}" alt="${game.Name} Thumbnail" class="game-thumbnail" loading="lazy">
    <div class="game-info">
        <div class="info-item"><span class="info-label">Country</span>${game.Country}</div>
        <div class="info-item"><span class="info-label">Genre</span><span class="genre">${game.Genre}</span></div>
        <div class="info-item">
    <span class="info-label">Description</span>
    <div class="description">
        <span class="game-description">${game.Description}</span>
        <span class="read-more" id="readMoreBtn">Read More</span>
    </div>
    <div id="message" style="display: none; color: red;">Not available yet</div>
</div>
        <div class="info-item"><span class="info-label">Publisher</span>${game.Publisher_Names}</div>
        <div class="info-item"><span class="info-label">Developer</span>${game.Developer_Names}</div>
        <div class="info-item"><span class="info-label">Platform</span>${game.Platform}</div>
        <div class="info-item"><span class="info-label">Release Date</span>${game.Release_Date instanceof Date && !isNaN(game.Release_Date) ? game.Release_Date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : "To be announced"}</div>
        <a href="${game.Steam_Link}" class="platform-link steam-link" target="_blank">
  <img src="assets/steam.webp" alt="Steam" class="platform-logo">
</a>
${game.Epic_Link && game.Epic_Link !== "Unknown" ? `
<a href="${game.Epic_Link}" class="platform-link epic-link" target="_blank">
  <img src="assets/epic.webp" alt="Epic Games" class="platform-logo">
</a>` : ''}
${game.Playstation_Link && game.Playstation_Link !== "Unknown" ? `
<a href="${game.Playstation_Link}" class="platform-link playstation-link" target="_blank">
  <img src="assets/playstation.webp" alt="PlayStation" class="platform-logo">
</a>` : ''}
${game.Xbox_Link && game.Xbox_Link !== "Unknown" ? `
<a href="${game.Xbox_Link}" class="platform-link xbox-link" target="_blank">
  <img src="assets/xbox.webp" alt="Xbox" class="platform-logo">
</a>` : ''}
${game.Switch_Link && game.Switch_Link !== "Unknown" ? `
<a href="${game.Switch_Link}" class="platform-link nintendo-link" target="_blank">
  <img src="assets/nintendo.webp" alt="Nintendo" class="platform-logo">
</a>` : ''}
        </div>
        
</div>`;
        }

        function renderGames(gamesData) {
            const container = document.getElementById('gameContainer');
            container.innerHTML = gamesData.map(game => createGameCard(game)).join('');

            container.addEventListener('click', function (e) {
                if (e.target.classList.contains('read-more')) {
                    const card = e.target.closest('.game-card');
                    if (card) {
                        card.classList.toggle('expanded');
                        e.target.textContent = card.classList.contains('expanded') ? 'Not available yet, sorry!' : 'Read More';
                    }
                }
            });
        }

        function bitvectorAND(...vectors) {
            return vectors[0].map((_, index) =>
                vectors.reduce((acc, vector) => acc & vector[index], ~0)
            );
        }

        function filter_and_render(bitVector) {
            const filteredGames = allGames.filter((_, index) => bitVector[index] == 1);
            renderGames(filteredGames);
        }

        function vector_state() {
            return bitvectorAND(bitVector_countries, bitVector_years, bitVector_genres, bitVector_platforms)
        }


        function refresh() {
            filter_and_render(vector_state());
            updateGameCountDisplay(vector_state());
        }

        // Function to filter games based on selected country
        function filter_by_country(country) {
            if (country === 'all') {
                bitVector_countries.fill(1)
            } else {
                bitVector_countries = allGames.map(game =>
                    game.Country == country ? 1 : 0
                );
            }
            refresh();
            // Highlight the appropriate button
            const filterContainer = document.getElementById('filterButtons');
            filterContainer.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
                if ((country === 'all' && btn.textContent === 'All Countries') ||
                    btn.textContent === country) {
                    btn.classList.add('active');
                }
            });
        }

        // Function to filter games based on selected year
        function filter_by_year(year) {
            if (year == 'all') {
                bitVector_years.fill(1)
            } else if (year == 'To be announced') {
                bitVector_years = allGames.map(game => {
                    return isNaN(game.Release_Date.getTime()) ? 1 : 0;
                });
            } else {
                bitVector_years = allGames.map(game => {
                    const releaseYear = game.Release_Date.getFullYear();
                    return releaseYear == year ? 1 : 0;
                });
            }
            refresh();
            // Highlight the appropriate button
            const filterContainer = document.getElementById('filterButtons-year');
            filterContainer.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
                if ((year === 'all' && btn.textContent === 'All Years') ||
                    btn.textContent === year) {
                    btn.classList.add('active');
                }
            });
        }

        // Main function to fetch data and render games
        async function main() {
            // Dynamically generate URLs for each country
            const baseUrl = 'https://raw.githubusercontent.com/jdiaz97/wherearethe.games/main/export/';
            const csvUrls = Array.from(uniqueCountries).map(country => `${baseUrl}${country}.csv`);

            try {
                allGames = await fetchMultipleCSVData(csvUrls);
                bitVector_countries = new Array(allGames.length).fill(1);  // Initialize with size 10 and all 0s
                bitVector_years = new Array(allGames.length).fill(1);  // Initialize with size 10 and all 0s
                bitVector_genres = new Array(allGames.length).fill(1);  // Initialize with size 10 and all 0s
                bitVector_platforms = new Array(allGames.length).fill(1);  // Initialize with size 10 and all 0s
                filter_and_render(bitVector_years);
                updateGameCountDisplay(bitVector_years);
            } catch (error) {
                console.error('Error fetching or processing data:', error);
            }

            createCountryFilterButtons();
            createGenreFilterButtons();
            createYearFilterButtons();
            createPlatformFilterButtons();
        }

        main();

        // Assume allGames is an array of objects with Name and Release_Date properties

const orderBySelect = document.getElementById('order-by');
const sortToggleButton = document.getElementById('sort-toggle');
let currentSortOrder = 'ascending';

function reorder_by_indices(indices){
    // Use the sorted indices to reorder allGames and bitvectors
    allGames = indices.map(i => allGames[i]);
    bitVector_countries = indices.map(i => bitVector_countries[i]);
    bitVector_years = indices.map(i => bitVector_years [i]);
    bitVector_genres = indices.map(i => bitVector_genres[i]);
    bitVector_platforms = indices.map(i => bitVector_platforms[i]);
}

function sortGames() {
    const sortOrder = currentSortOrder; // Ascending vs Descending

    let indices = Array.from(Array(allGames.length).keys());

    // Sort the indices based on the game data
    indices.sort((a, b) => {
        let comparison = allGames[a].Name.localeCompare(allGames[b].Name);
        return sortOrder === 'ascending' ? comparison : -comparison;
    });

    reorder_by_indices(indices)
    refresh();
}

orderBySelect.addEventListener('change', sortGames);

sortToggleButton.addEventListener('click', () => {
    currentSortOrder = currentSortOrder === 'ascending' ? 'descending' : 'ascending';
    sortToggleButton.setAttribute('data-order', currentSortOrder);
    document.getElementById('sort-text').textContent = currentSortOrder.charAt(0).toUpperCase() + currentSortOrder.slice(1);
    document.getElementById('arrow').textContent = currentSortOrder === 'ascending' ? '↑' : '↓';
    sortGames();
});


    </script>
</body>

</html>